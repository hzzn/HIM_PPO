import numpy as np
import gym
from gym import spaces
import torch
from pandocfilters import applyJSONFilters
from torch.distributions import Multinomial, Categorical
from torch.functional import F
from win32comext.axscript.client.framework import state_map


class HospitalEnv(gym.Env):

    def __init__(self, config):
        # === Pool structure ===
        self.num_pools = config["num_pools"]  # ùí•: Number of pools
        self.J = self.num_pools

        # === Server configuration ===
        self.N_j = torch.tensor(config["num_servers"],
                                                 dtype=torch.int)  # N_j: Number of beds per pool

        # === Hourly arrival and discharge rates ===
        self.hourly_arrival_rate = torch.tensor(config["arrival_rate_hourly"], dtype=torch.float)  # Œª_j(t)
        self.daily_arrival_rate = torch.sum(self.hourly_arrival_rate, dim=1)  # Œõ_j: Total arrival per day

        self.hourly_discharge_rate = torch.tensor(config["discharge_rate_hourly"], dtype=torch.float) # h_dis 
        self.discharge_cdf = torch.cumsum(self.hourly_discharge_rate, dim = 1) # CDF for the discharge time ÂèÇÁÖßp33 B.1.
        self.daily_discharge_rate = torch.tensor(config["discharge_rate_daily"], dtype=torch.float) # Total discharge per day

        # === Decision epoch ===
        self.num_epochs_per_day = config["num_epochs_per_day"]  # m: Number of epochs per day
        self.epoch_times = torch.tensor(
            [i * (24 / self.num_epochs_per_day) for i in range(self.num_epochs_per_day)], dtype=torch.float)

        # === Day tracking ===
        self.day_count = 0  # t: current day t
        self.epoch_index_today = 0  # H(t): current epoch index within day

        # === State representation (X_j, Y_j, h) ===
        self.X_j = torch.zeros(self.num_pools, dtype=torch.int)  # X_j: current number of customers in pool j
        self.Y_j = torch.zeros(self.num_pools,
                               dtype=torch.int)  # Y_j: number of patients to be discharged today in each pool
        self.state = torch.cat([self.X_j, self.Y_j, torch.tensor([self.epoch_index_today])], dim=0)
        self.overflow = torch.zeros(self.num_pools, dtype=torch.int)  # Overflow patients

        # === Action representation ===
        self.overflow_and_wait_decision = torch.zeros(self.num_pools, self.num_pools,
                                                      dtype=torch.int)  # F(t_k): overflow/wait decisions matrix
        self.mask = torch.tensor(config["mask"], dtype=torch.int)  # Mask for invalid actions

        # === Waiting count and in-service tracking ===
        self.waiting_count_list = torch.zeros(self.num_pools, dtype=torch.int)  # Q_j: Waiting count per class
        self.in_service_count_list = torch.zeros(self.num_pools, dtype=torch.int)  # Z_j: In-service count

        # === Cost structure ===
        self.holding_cost = torch.tensor(config["waiting_cost"],
                                                   dtype=torch.float)  # C_j: Cost per unit of waiting
        self.overflow_cost = torch.tensor(config["overflow_cost"],
                                                 dtype=torch.float)  # B_ij: Overflow cost from class i to pool j

        # === One-epoch cost tracking ===
        self.current_epoch_cost = 0.0  # g(s, f): One-epoch cost under action f

        self.reset()

    def reset(self, is_random=False):
        """
        Reset the environment to the beginning of the simulation (day 0, epoch 0).
        """
        self.day_count = 0  # t = 0
        self.epoch_index_today = 0  # h(t) = 0
        if is_random:
            self.X_j = torch.cat([torch.randint(2*n//3, n+1, (1,)) for n in self.N_j])
        else:
            self.X_j = torch.zeros(self.num_pools, dtype=torch.int)  # X_j: current number of customers in pool j
        self.Y_j = torch.zeros(self.num_pools, dtype=torch.int)  # Y_j: number of patients to be discharged today in each pool
        self.state = torch.cat([self.X_j, self.Y_j, torch.tensor([self.epoch_index_today])], dim=0)

        self.waiting_count_list = torch.zeros(self.num_pools, dtype=torch.int)  # Waiting count per class
        self.in_service_count_list = torch.zeros(self.num_pools, dtype=torch.int)  # In-service count per class
        
        return self.state

    def step(self, logits):
        """
        Performs one transition step in the environment based on the given action.
        """
        self.post_state = self.state.clone()
        action = self.simulated_action(logits)  # Sample an action from the action probabilities

        self.compute_post_action_state(action)
        cost = self.compute_cost(action)

        # Simulate Poisson arrivals and Binomial discharges
        prob = self.simulate_exogenous_events()

        return self.state, cost, action
    
    def overflow_step(self):
        self.post_state = self.state.clone()
        self.overflow = torch.clamp(self.X_j - self.N_j, min=0)
        # ÂàùÂßãÂåñÂä®‰ΩúÁü©ÈòµÔºàÊØè‰∏™ÁóÖÊàøÁöÑÊÇ£ËÄÖÂàÜÈÖçÔºâ
        action = torch.zeros(self.num_pools, self.num_pools, dtype=torch.int)
        for i in range(self.J):
            num_patients = self.overflow[i]
            for _ in range(num_patients):
               print() 
        self.compute_post_action_state(action)
        cost = self.compute_cost(action)

        # Simulate Poisson arrivals and Binomial discharges
        prob = self.simulate_exogenous_events()

        return self.state, cost, action

    def simulated_action(self, logits):
        # ËÆ°ÁÆóÊ∫¢Âá∫ÊÇ£ËÄÖÊï∞
        self.overflow = torch.clamp(self.X_j - self.N_j, min=0)
        # ÂàùÂßãÂåñÂä®‰ΩúÁü©ÈòµÔºàÊØè‰∏™ÁóÖÊàøÁöÑÊÇ£ËÄÖÂàÜÈÖçÔºâ
        action = torch.zeros(self.num_pools, self.num_pools, dtype=torch.int)
        action_prob = F.softmax(logits, dim=-1)  # ËÆ°ÁÆóÂä®‰ΩúÊ¶ÇÁéá
        # Âà§Êñ≠Âπ∂ÈáçÊñ∞ÈááÊ†∑Áõ¥Âà∞ÂèØË°å
        for i in range(self.J):
            num_patients = self.overflow[i]
            dist = Categorical(action_prob[i, :])  # ÂàõÂª∫ Categorical ÂàÜÂ∏ÉÂØπË±°
            for _ in range(num_patients):
                num_resample = 0 # ËÆ∞ÂΩïÈáçÈááÊ†∑Ê¨°Êï∞, ‰∏∫ÈáçÈááÊ†∑Ê¨°Êï∞ËÆæÂÆöÈòàÂÄº, Èò≤Ê≠¢Èô∑ÂÖ•Ê≠ªÂæ™ÁéØ
                while True:  # ÈáçÂ§çÈááÊ†∑Áõ¥Âà∞ÂæóÂà∞ÂèØË°åÁöÑÂàÜÈÖç
                    if num_resample >= 5:
                        action[i, i] += 1
                        self.X_j[i] += 1
                        break     

                    target = dist.sample()  # ÈááÊ†∑

                    if self.N_j[target] > self.X_j[target]:
                        action[i, target] += 1
                        self.X_j[target] += 1
                        break # Â¶ÇÊûúÂàÜÈÖçÂèØË°åÔºåÈÄÄÂá∫Âæ™ÁéØ, Âê¶ÂàôÁªßÁª≠Âæ™ÁéØÈáçÊñ∞ÈááÊ†∑

                    num_resample += 1

        return action


    def compute_post_action_state(self, action):
        """
        :param state: shape = (2J + 1,) -> [x_0..x_J-1, y_0..y_J-1, t]
        :param action: shape = (J, J) -> action[i, j] = Á±ªÂà´ i ÂàÜÈÖçÂà∞ÁóÖÊàø j ÁöÑÊÇ£ËÄÖÊï∞Èáè
        :return: post-action Áä∂ÊÄÅ
        """

        self.X_j = self.X_j - self.overflow
        t = self.state[-1:]

        self.post_state = torch.cat([self.X_j, self.Y_j, t])

        return self.post_state


    def compute_cost(self, action):
        """
        :param post_state: shape = (2J + 1,) -> [x+, y, t+1]
        :param action: shape = (J, J), Ë°®Á§∫ overflow ÂàÜÈÖç
        :return: float scalar cost
        """

        # 1. holding cost: max(x_j^+ - N_j, 0)
        q_post = torch.clamp(self.X_j - self.N_j, min=0)
        holding = torch.sum(self.holding_cost * q_post)

        # 2. overflow cost: sum_{i,j} B_{i,j} * f_{i,j}
        overflow = torch.sum(self.overflow_cost * action)

        return holding + overflow

    def simulate_exogenous_events(self):

        h = int(self.post_state[-1].item())

        # Âà§Êñ≠ÊòØÂê¶‰∏∫ÂçàÂ§úÔºàh == 0Ôºâ
        is_midnight = (h == 0)

        # ËÆ°ÁÆó t ÂØπÂ∫îÁöÑÂ∞èÊó∂ÊÆµÔºàÂΩìÂâç 3 Â∞èÊó∂ÊÆµÁöÑËµ∑ÂßãÂ∞èÊó∂Á¥¢ÂºïÔºâ
        t = h * 3  # h=0 -> t=0, h=1 -> t=3, ..., h=7 -> t=21

        # ======== aj: Âà∞ËææÊÇ£ËÄÖ‰∫∫Êï∞ÔºàÊ≥äÊùæÂàÜÂ∏ÉÔºâ========
        aj = torch.zeros(self.J, dtype=torch.int)
        for j in range(self.J):
            for dt in range(3):
                lam = self.hourly_arrival_rate[j][t + dt]
                aj[j] += torch.poisson(torch.tensor([lam])).int().item()

        if is_midnight:
            # ======== ÂçàÂ§úÊõ¥Êñ∞ÈÄªËæë ========
            # bj: ËÆ°ÂàíÂá∫Èô¢ÔºàÊØèÊó•Ôºâ
            bj = torch.zeros(self.J, dtype=torch.int)
            for j in range(self.J):
                cap = min(self.X_j[j], self.N_j[j])  # ÂΩìÂâçÁóÖÊàøÁúüÂÆûÂÆπÈáè‰∏ãÁöÑÊÇ£ËÄÖÊï∞
                bj[j] = torch.distributions.Binomial(
                    total_count=cap, probs=self.daily_discharge_rate[j]
                ).sample().int()

            self.X_j = self.X_j + aj  # Âà∞ËææÊÇ£ËÄÖÂä†ÂÖ•
            self.Y_j = bj  # ËÆæÁΩÆÂΩìÂ§©ÈúÄË¶ÅÂá∫Èô¢ÁöÑÊÇ£ËÄÖ

        else:
            # ======== ÈùûÂçàÂ§úÊõ¥Êñ∞ÈÄªËæë ======== ÂèÇÁÖßp33 B.1.
            dj = torch.zeros(self.J, dtype=torch.int)
            for j in range(self.J):
                if self.Y_j[j] > 0:
                    eps = 1e-10
                    F_h = self.discharge_cdf[j][3*h]
                    F_h_prime = self.discharge_cdf[j][3*(h-1)]
                    probs = (F_h - F_h_prime + eps) / (1 - F_h_prime + eps) # ÂèÇÁÖßp33 B.1.
                    out = torch.distributions.Binomial(
                        total_count=self.Y_j[j], probs=probs
                    ).sample().int() # ÂèÇÁÖßp33 B.1.
                    
                    dj[j] += out

            self.X_j = self.X_j + aj - dj
            self.Y_j = self.Y_j - dj

        # Êó∂Èó¥Êõ¥Êñ∞
        h = (h + 1) % self.num_epochs_per_day

        if h == 0:
            self.day_count += 1  # ÊØèÊó•ÈÄíÂ¢û

        # ÊãºÊé•Êñ∞ÁöÑÁä∂ÊÄÅ
        self.state = torch.cat([self.X_j, self.Y_j, torch.tensor([h])])

        self.epoch_index_today = h

        transition_prob = 0

        return transition_prob
